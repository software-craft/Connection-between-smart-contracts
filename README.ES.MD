# ConecciÃ³n entre Smart Contracts

Este proyecto demuestra diferentes patrones de interacciÃ³n entre contratos inteligentes en Solidity, incluyendo validaciÃ³n de permisos, manejo de errores, contratos `payable` y comunicaciÃ³n a travÃ©s de interfaces. EstÃ¡ diseÃ±ado como una base educativa y de referencia para desarrolladores que deseen aprender buenas prÃ¡cticas en Ethereum.

---

## ğŸ“ Estructura del Proyecto

CONNECTION-BETWEEN-SMART-CONTRACTS/
â”œâ”€â”€ states/
â”‚   â””â”€â”€ vm-prague/                   
â”‚       â”œâ”€â”€ state.json
â”‚       â””â”€â”€ artifacts/
â”œâ”€â”€ checks/
â”‚   â””â”€â”€ checkTest.sol                 
â”œâ”€â”€ peyablefunction/
â”‚   â”œâ”€â”€ payablecontract2.sol           
â”‚   â””â”€â”€ peyablesmartcontract.sol       
â”œâ”€â”€ SSConnect/                          
â”‚   â”œâ”€â”€ checks/
â”‚   â”‚   â””â”€â”€ checkTest.sol               
â”‚   â”œâ”€â”€ interface/
â”‚   â”‚   â””â”€â”€ IResult.sol                  
â”‚   â”œâ”€â”€ validators/
â”‚   â”‚   â”œâ”€â”€ result.sol                    
â”‚   â”‚   â””â”€â”€ sum.sol                        
â”œâ”€â”€ LICENSE                              
â””â”€â”€ README.md

---

## âš™ï¸ Contratos Inteligentes

### 1. `RequireTest` (mÃºltiples versiones)
Ilustra tres formas de verificar que el remitente (`msg.sender`) sea el administrador:
- **`checkAdmin`**: usa `if (msg.sender != admin) revert();` sin mensaje.
- **`checkAdminRequire`**: emplea `require` con un cÃ³digo de error (`"01"`).
- **`adminCheckCustomErrors`**: utiliza un error personalizado (`SenderNotAdmin`).

Estos ejemplos muestran cÃ³mo gestionar el control de acceso y optimizar el consumo de gas.

### 2. `PayableContractV2` y `PeyableContract`
- **`sendEther`**: funciÃ³n `payable` que permite al contrato recibir Ether.
- **`withDrawEther`**: retira una cantidad especÃ­fica de Ether hacia el remitente mediante `call`.

Ambos contratos sirven como base para manejar fondos dentro de un contrato.

### 3. `IResult` (Interfaz)
Define las funciones que debe implementar un contrato compatible:
- `addition(uint256 num1_, uint256 num2_)`
- `setResult(uint256 num_)`
- `setFee(uint256 newFee_)`

### 4. `Result`
Almacena:
- `result`: resultado de una operaciÃ³n.
- `admin`: direcciÃ³n del administrador (asignada en el constructor).
- `fee`: tarifa (inicializada en 3).

**Funciones principales:**
- `setResult(uint256 num_)`: actualiza el resultado (sin restricciÃ³n de acceso).
- `setFee(uint256 newfee_)`: solo el administrador puede modificar la tarifa.

### 5. `Sum`
Contrato que interactÃºa con una direcciÃ³n de `Result` (inyectada en el constructor).
- **`addition`**: calcula la suma de dos nÃºmeros y llama a `setResult` del contrato `Result`.
- **`setFee`**: invoca `setFee` en el contrato `Result` para actualizar la tarifa.

Este ejemplo muestra cÃ³mo un contrato puede llamar a funciones de otro contrato a travÃ©s de una interfaz.

---

## ğŸ”— InteracciÃ³n entre Contratos

El flujo principal se da entre `Sum` y `Result`:
1. Se despliega primero `Result` (con una direcciÃ³n admin).
2. Se despliega `Sum` pasando la direcciÃ³n de `Result`.
3. Al llamar a `Sum.addition(5,3)`, este contrato calcula `8` y ejecuta `IResult(result).setResult(8)`, actualizando el estado en `Result`.
4. De manera similar, `Sum.setFee(10)` modifica la tarifa en `Result`, siempre que el remitente sea el admin.

---

## ğŸš€ Despliegue y Pruebas

### Requisitos
- Compilador Solidity `0.8.30`.
- Herramientas como Hardhat, Foundry o Truffle.
